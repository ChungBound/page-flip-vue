<template>
  <div
    class="relative w-full flex flex-col items-center justify-center overflow-visible min-h-[280px]"
  >
    <svg
      :width="280"
      :height="280"
      viewBox="0 0 280 280"
      class="overflow-visible"
    >
      <!-- ÂÆö‰πâÂõæÁâáÊ®°Âºè -->
      <defs>
        <pattern
          id="headPattern"
          patternUnits="objectBoundingBox"
          width="1"
          height="1"
        >
          <!-- Âä®ÊÄÅÁªëÂÆöÂõæÁâáË∑ØÂæÑ - Â¢ûÂ§ßÂõæÁâáÂ∞∫ÂØ∏Âπ∂Â±Ö‰∏≠ -->
          <image
            :href="headImagePath || '/images/head-default.png'"
            x="-340"
            y="-380"
            width="1000"
            height="1000"
            preserveAspectRatio="xMidYMid slice"
          />
        </pattern>
      </defs>

      <!-- ËÉåÊôØ - ÂèØÈÄâÊã©‰ΩøÁî®ÂõæÁâáÊàñÁÆÄÂçïÂúÜÂΩ¢ -->
      <template v-if="useImageBackground">
        <!-- ‰ΩøÁî®ÂõæÁâáËÉåÊôØ -->
        <circle
          cx="140"
          cy="150"
          r="140"
          fill="url(#headPattern)"
          stroke="#d1d5db"
          stroke-width="0"
        />
      </template>
      <template v-else>
        <!-- ‰ΩøÁî®ÁÆÄÂçïÂúÜÂΩ¢ËÉåÊôØ -->
        <circle
          cx="140"
          cy="150"
          r="100"
          fill="#e5e7eb"
          stroke="#d1d5db"
          stroke-width="2"
        />
      </template>

      <!-- ËøûÊé•Á∫øÁªÑ -->
      <g stroke="#4b5563" stroke-width="1.5" opacity="0.7" fill="none">
        <path
          v-for="(pair, idx) in sensorLinks"
          :key="idx"
          :d="createCurvePath(sensorsMap[pair[0]], sensorsMap[pair[1]])"
          class="sensor-connection-line"
        />
      </g>

      <!-- ‰º†ÊÑüÂô®ÁÇπÁªÑ -->
      <g v-for="sensor in sensors" :key="sensor.id">
        <!-- ‰º†ÊÑüÂô®Èò¥ÂΩ± -->
        <circle
          :cx="sensor.x + 1"
          :cy="sensor.y + 1"
          :r="7"
          fill="rgba(0,0,0,0.2)"
        />
        <!-- ‰∏ª‰º†ÊÑüÂô® - ÁßªÈô§ÊÇ¨ÂÅúÂä®Áîª -->
        <circle
          :cx="sensor.x"
          :cy="sensor.y"
          :r="6"
          :fill="
            getColor(activeTab === 'contact' ? sensor.contact : sensor.eeg)
          "
          :stroke="selectedSensor === sensor.id ? '#3b82f6' : '#fff'"
          stroke-width="2"
          @click.stop="selectSensor(sensor.id, $event)"
          class="sensor-node"
        />
        <!-- ‰º†ÊÑüÂô®Ê†áÁ≠æ -->
        <text
          :x="sensor.x"
          :y="sensor.y + 20"
          text-anchor="middle"
          class="text-xs font-medium fill-gray-600 sensor-label"
        >
          {{ sensor.label }}
        </text>
      </g>
    </svg>

    <!-- Info card overlay - ‰ΩøÁî®PortalÂà∞bodyÈÅøÂÖçÂ∏ÉÂ±ÄÂΩ±Âìç -->
    <teleport to="body" v-if="selectedSensorObj">
      <div class="fixed inset-0 z-30" @click="clearSelected"></div>
      <div
        class="fixed z-40 transform -translate-x-1/2"
        :style="popupPosition"
        @click.stop
      >
        <div
          class="bg-white rounded-2xl shadow-2xl px-6 py-4 border border-gray-100 min-w-[240px] max-w-[280px] flex flex-col gap-3 relative animate-fadein"
        >
          <div
            class="font-semibold text-gray-800 mb-1 text-base flex items-center gap-2"
          >
            <span>{{ selectedSensorObj.label }}</span>
            <span class="text-xs text-gray-400">Sensor</span>
          </div>
          <div class="flex items-center gap-4 text-sm">
            <span class="text-gray-600">Contact</span>
            <span
              :style="getDotStyle(selectedSensorObj.contact)"
              class="sensor-dot"
            ></span>
            <span class="text-gray-600 ml-2">EEG</span>
            <span
              :style="getDotStyle(selectedSensorObj.eeg)"
              class="sensor-dot"
            ></span>
          </div>
          <div class="flex items-center gap-2 text-xs text-gray-500 mt-1">
            <span>Contact:</span>
            <span>{{ getSensorStatus(selectedSensorObj, "contact") }}</span>
            <span class="ml-2">EEG:</span>
            <span>{{ getSensorStatus(selectedSensorObj, "eeg") }}</span>
          </div>
          <button
            class="absolute top-2 right-2 text-gray-400 hover:text-blue-500"
            @click="clearSelected"
          >
            <svg
              class="w-4 h-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M6 18L18 6M6 6l12 12"
              ></path>
            </svg>
          </button>
        </div>
      </div>
    </teleport>

    <!-- Ë¥®ÈáèÁôæÂàÜÊØîÊòæÁ§∫ -->
    <div
      class="absolute left-1/2 bottom-[-3rem] -translate-x-1/2 text-2xl font-bold text-red-500 select-none pointer-events-none"
    >
      {{ qualityPercentage }}%
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch, nextTick } from "vue";

const props = defineProps({
  sensors: Array,
  sensorLinks: Array,
  activeTab: {
    type: String,
    default: "contact",
  },
  // Êñ∞Â¢ûÔºöÊòØÂê¶‰ΩøÁî®ÂõæÁâáËÉåÊôØ
  useImageBackground: {
    type: Boolean,
    default: false,
  },
  // Êñ∞Â¢ûÔºöËá™ÂÆö‰πâÂõæÁâáË∑ØÂæÑ
  headImagePath: {
    type: String,
    default: "/path/to/your/head-image.png",
  },
});

const selectedSensor = ref(null);
const popupPosition = ref({ left: "50%", top: "50%" }); // Â≠òÂÇ®ÂºπÁ™ó‰ΩçÁΩÆ
const sensorsMap = computed(() =>
  Object.fromEntries(props.sensors.map((s) => [s.label, s]))
);
const selectedSensorObj = computed(() =>
  props.sensors.find((s) => s.id === selectedSensor.value)
);

// ËÆ°ÁÆóË¥®ÈáèÁôæÂàÜÊØî
const qualityPercentage = computed(() => {
  if (!props.sensors || props.sensors.length === 0) return 0;

  const qualityField = props.activeTab === "contact" ? "contact" : "eeg";
  const validSensors = props.sensors.filter((s) => s[qualityField] >= 0);
  if (validSensors.length === 0) return 0;

  const totalQuality = validSensors.reduce((sum, sensor) => {
    const quality = sensor[qualityField];
    return sum + (quality >= 0 ? (quality / 4) * 100 : 0);
  }, 0);

  return Math.round(totalQuality / validSensors.length);
});

function getColor(val) {
  switch (val) {
    case 0:
      return "#374151"; // Ê∑±ÁÅ∞Ëâ≤ - Êó†ËøûÊé•
    case 1:
      return "#ef4444"; // Á∫¢Ëâ≤ - Â∑Æ
    case 2:
      return "#f59e0b"; // Ê©ôËâ≤ - ‰∏ÄËà¨
    case 3:
      return "#eab308"; // ÈªÑËâ≤ - ËâØÂ•Ω
    case 4:
      return "#22c55e"; // ÁªøËâ≤ - ‰ºòÁßÄ
    default:
      return "#9ca3af"; // ÁÅ∞Ëâ≤ - Êú™Áü•
  }
}

function getDotStyle(val) {
  return {
    background: getColor(val),
    boxShadow: "0 2px 8px 0 rgba(0,0,0,0.15)",
    width: "18px",
    height: "18px",
    borderRadius: "50%",
    display: "inline-block",
    border: "2px solid #fff",
    outline: "1.5px solid #e5e7eb",
  };
}

function selectSensor(id, event) {
  selectedSensor.value = id;

  // ‰ΩøÁî®Èº†Ê†á‰∫ã‰ª∂ÁöÑÂÆûÈôÖÂùêÊ†á
  if (event) {
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    // Ëé∑ÂèñÈº†Ê†áÁÇπÂáªÁöÑÂÆ¢Êà∑Á´ØÂùêÊ†áÔºàÁõ∏ÂØπ‰∫éËßÜÁ™óÔºâ
    let mouseX = event.clientX;
    let mouseY = event.clientY;

    // ÂºπÁ™óÂ∞∫ÂØ∏‰º∞ÁÆó
    const popupWidth = 240;
    const popupHeight = 140;

    let left = mouseX;
    let top = mouseY + 20; // ÈªòËÆ§ÊòæÁ§∫Âú®Èº†Ê†á‰∏ãÊñπ

    // Ê∞¥Âπ≥‰ΩçÁΩÆË∞ÉÊï¥ - Á°Æ‰øù‰∏çË∂ÖÂá∫ËßÜÁ™ó
    if (left + popupWidth / 2 > viewportWidth - 20) {
      left = viewportWidth - popupWidth / 2 - 20;
    } else if (left - popupWidth / 2 < 20) {
      left = popupWidth / 2 + 20;
    }

    // ÂûÇÁõ¥‰ΩçÁΩÆË∞ÉÊï¥ - Â¶ÇÊûú‰∏ãÊñπÁ©∫Èó¥‰∏çË∂≥ÔºåÊòæÁ§∫Âú®‰∏äÊñπ
    if (top + popupHeight > viewportHeight - 20) {
      top = mouseY - popupHeight - 10;
    }

    // Á°Æ‰øùÈ°∂ÈÉ®‰∏çË∂ÖÂá∫ËßÜÁ™ó
    if (top < 20) {
      top = 20;
    }

    // Áî±‰∫é‰ΩøÁî®fixedÂÆö‰ΩçÔºåÁõ¥Êé•‰ΩøÁî®ÂÆ¢Êà∑Á´ØÂùêÊ†á
    popupPosition.value = {
      left: `${left}px`,
      top: `${top}px`,
    };

    // console.log("üéØ Popup position:", { mouseX, mouseY, left, top });
  }
}

function clearSelected() {
  selectedSensor.value = null;
}

function getSensorStatus(sensor, type) {
  const value = type === "contact" ? sensor.contact : sensor.eeg;
  switch (value) {
    case 4:
      return "Excellent";
    case 3:
      return "Good";
    case 2:
      return "Fair";
    case 1:
      return "Poor";
    case 0:
      return type === "contact" ? "No Contact" : "No Signal";
    default:
      return "Unknown";
  }
}

function createCurvePath(start, end) {
  if (!start || !end) return "";

  const dx = end.x - start.x;
  const dy = end.y - start.y;
  const distance = Math.sqrt(dx * dx + dy * dy);

  // ËÆ°ÁÆó‰∏≠ÁÇπ
  const midX = start.x + dx / 2;
  const midY = start.y + dy / 2;

  // ÂºßÂ∫¶Â§ßÂ∞è‰∏éË∑ùÁ¶ªÊàêÊØî‰æãÔºåÊ†πÊçÆË∑ùÁ¶ªË∞ÉÊï¥
  const baseCurvature = Math.min(distance * 0.15, 25);

  // Ê†πÊçÆÂ§¥ÈÉ®‰∏≠ÂøÉÁÇπ(140, 150)Ë∞ÉÊï¥ÂºßÁ∫øÊñπÂêë
  const centerX = 140;
  const centerY = 150;

  // ËÆ°ÁÆó‰∏≠ÁÇπÂà∞‰∏≠ÂøÉÁöÑÊñπÂêë
  const toCenterX = centerX - midX;
  const toCenterY = centerY - midY;
  const toCenterDistance = Math.sqrt(
    toCenterX * toCenterX + toCenterY * toCenterY
  );

  // Ê†áÂáÜÂåñÂà∞‰∏≠ÂøÉÁöÑÊñπÂêëÂêëÈáè
  const toCenterNormX = toCenterX / toCenterDistance;
  const toCenterNormY = toCenterY / toCenterDistance;

  // ÊéßÂà∂ÁÇπÂÅèÂêëÂ§¥ÈÉ®Â§ñ‰æßÔºàËøúÁ¶ª‰∏≠ÂøÉÊñπÂêëÂºØÊõ≤Ôºâ- ÂèçÂêë
  const controlX = midX - toCenterNormX * baseCurvature;
  const controlY = midY - toCenterNormY * baseCurvature;

  // ‰ΩøÁî®‰∫åÊ¨°Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø
  return `M${start.x},${start.y} Q${controlX},${controlY} ${end.x},${end.y}`;
}
</script>

<style scoped>
.sensor-dot {
  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  border: 2px solid #fff;
  outline: 1.5px solid #e5e7eb;
  width: 18px;
  height: 18px;
  display: inline-block;
  vertical-align: middle;
}

/* ‰º†ÊÑüÂô®ËøûÊé•Á∫øÊ†∑Âºè */
.sensor-connection-line {
  transition: stroke-width 0.3s ease, opacity 0.3s ease;
}

.sensor-connection-line:hover {
  stroke-width: 2;
  opacity: 0.7;
}

/* ‰º†ÊÑüÂô®ËäÇÁÇπÊ†∑Âºè - ÁßªÈô§ÊÇ¨ÂÅúÂä®Áîª */
.sensor-node {
  cursor: pointer;
  transition: stroke-width 0.2s ease;
}

.sensor-node:hover {
  stroke-width: 3;
  /* ÁßªÈô§‰∫Ü scale ÂèòÊç¢ÔºåÂè™‰øùÁïôÊèèËæπÂèòÂåñ */
}

/* ‰º†ÊÑüÂô®Ê†áÁ≠æÊ†∑Âºè */
.sensor-label {
  pointer-events: none;
  user-select: none;
}

/* ÂºπÂá∫Âç°ÁâáÂä®Áîª */
.animate-fadein {
  animation: fadein 0.2s ease-out;
}

@keyframes fadein {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* SVGÂìçÂ∫îÂºè */
svg {
  max-width: 100%;
  height: auto;
}

/* Á°Æ‰øùÂõæÁâáÂú®SVG‰∏≠Ê≠£Á°ÆÊòæÁ§∫ */
pattern image {
  opacity: 0.8;
}
</style>
